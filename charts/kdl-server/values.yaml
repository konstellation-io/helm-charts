# Default values for kdl-server
# This is a YAML-formatted file
# Declare variables to be passed into your templates

global:
  # -- Specifies the registry to pull images from. Leave empty for the default registry
  imageRegistry: ""

  # -- Specifies the secrets to use for pulling images from private registries
  # Leave empty if no secrets are required
  # E.g.
  # imagePullSecrets:
  #   - name: myRegistryKeySecretName
  imagePullSecrets: []

  # -- Environment variables to configure application
  env: {}
    # MY_VARIABLE: value

  # -- Variables from secrets
  envFromSecrets: {}
    # MY_VARIABLE:
    #  name: <name-secret>
    #  key: secret_key

  # -- Variables from configMap
  envFromConfigMap: {}
    # MY_VARIABLE:
    #  name: <name-configmap>
    #  key: key

  # -- Variables from files managed by you
  # </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#configure-all-key-value-pairs-in-a-configmap-as-container-environment-variables
  envFromFiles: {}
    # - secretRef:
    #     name: <name-secret>
    # - configMapRef:
    #     name: <name-configmap>

  # TODO: legacy values, remove in future versions
  # -- KDL Server instance name
  serverName: "local-server"

  # -- The DNS domain name that will serve the application
  domain: kdl.local

  # -- TLS configuration
  ingress:
    tls:
      enabled: false

  # -- (DEPRECATION) Configure MongoDB string URI
  mongodb:
    connectionString:
      # -- The name of the secret that contains a key with the MongoDB connection string.
      secretName: ""
      # -- The name of the secret key that contains the MongoDB connection string.
      secretKey: ""

# -- Image registry
# The image configuration for the base service
image:
  # The repository of the image
  repository: konstellation/kdl-server
  # The pull policy for the image
  pullPolicy: IfNotPresent
  # The image tag
  tag: 1.38.0

# -- String to partially override kdl-server.fullname template (will maintain the release name)
nameOverride: ""

# -- String to fully override kdl-server.fullname template
fullnameOverride: ""

# -- Specifies the secrets to use for pulling images from private registries
# Leave empty if no secrets are required
# E.g.
# imagePullSecrets:
#   - name: myRegistryKeySecretName
imagePullSecrets: []

# -- Enable creation of ServiceAccount
# </br> Ref: https://kubernetes.io/docs/concepts/security/service-accounts/
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# -- Enable or disable test connection
testConnection:
  # Specifies whether a test connection should be created
  enabled: false
  # The repository of the image
  repository: busybox
  # Overrides the image tag whose default is the chart appVersion
  tag: ""

# -- Environment variables to configure application
env: {}
  # MY_VARIABLE: value

# -- Variables from secrets
envFromSecrets: {}
  # MY_VARIABLE:
  #  name: <name-secret>
  #  key: secret_key

# -- Variables from configMap
envFromConfigMap: {}
  # MY_VARIABLE:
  #  name: <name-configmap>
  #  key: key

# -- Variables from files managed by you
# </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#configure-all-key-value-pairs-in-a-configmap-as-container-environment-variables
envFromFiles: {}
  # - secretRef:
  #     name: <name-secret>
  # - configMapRef:
  #     name: <name-configmap>

# -- Secrets values to create credentials and reference by envFromSecrets
# Generate Secret with following name: <release-name>-<name>
# </br> Ref: https://kubernetes.io/docs/concepts/configuration/secret/
secrets: {}
  # - name: secret-name
  #   data:
  #     my.key: |-
  #       my-content
  #     my_var: my-value

# -- Configure additional containers
# </br> Ref: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
initContainers: []
  # - name: my-container
  #   image: busybox
  #   command: ['sh', '-c', 'echo "Hello, World!"']

# -- Configure args
# </br> Ref: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
args: []
  # - -c
  # - echo "Hello, World!"

# -- Configure command
# </br> Ref: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
command: []
  # - echo
  # - "Hello, World!"

# -- Kubernetes service to expose Pod
# </br> Ref: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  # -- Kubernetes Service type. Allowed values: NodePort, LoadBalancer or ClusterIP
  type: ClusterIP
  # -- Kubernetes Service port
  port: 80
  # -- Kubernetes Service health check path
  # healthPath: ""
  # -- NodePort port (only when type is NodePort)
  # nodePort: 32000
  # -- Pod expose port
  targetPort: 3000
  # -- Pod extra ports
  # extraPorts:
  # - name: metrics
  #   port: 9080
  #   targetPort: 9080

# -- Ingress configuration to expose app
# </br> Ref: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  enabled: false
  className: ""
  annotations: {}
    # cert-manager.io/issuer: your-issuer
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"

    # This Chart has been developed using Nginx Ingress Controller by default.
    # Using the following default annotations ensures its correct operation.
    # Ref: https://kubernetes.github.io/ingress-nginx/
    #
    #nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    #nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    #nginx.ingress.kubernetes.io/proxy-connect-timeout: "3600"

    # Large values are needed here to serve big files from Filebrowser
    #
    # nginx.ingress.kubernetes.io/proxy-body-size: "1000000m"
  hosts:
  - host: chart-example.local
    paths:
    - path: /
      pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #    - chart-example.local

# -- NetworkPolicy configuration
# </br> Ref: https://kubernetes.io/docs/concepts/services-networking/network-policies/
networkPolicy:
  # -- Enable or disable NetworkPolicy
  enabled: false
  # -- Policy types
  policyTypes: []
    # - Ingress
    # - Egress
  ingress: []
    # - from:
    #   - ipBlock:
    #       cidr: 172.17.0.0/16
    #       except:
    #       - 172.17.1.0/24
    #   - namespaceSelector:
    #       matchLabels:
    #         project: myproject
    #   - podSelector:
    #       matchLabels:
    #         role: frontend
    #   ports:
    #   - protocol: TCP
    #     port: 6379
  egress: []
    # - to:
    #   - ipBlock:
    #       cidr: 10.0.0.0/24
    #   ports:
    #   - protocol: TCP
    #     port: 5978

# -- Configure lifecycle hooks
# </br> Ref: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/
# </br> Ref: https://learnk8s.io/graceful-shutdown
lifecycle: {}
  # preStop:
  #   exec:
  #     command: ["sh", "-c", "sleep 10"]
  # postStart:
  #   exec:
  #     command:
  #       - "/bin/sh"
  #       - "-c"
  #       - "ssh-keyscan -H gitea >> /app/.ssh/known_hosts"

# -- Configure Pod termination grace period
# </br> Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination
terminationGracePeriodSeconds: 30

# -- Configure liveness checker
# </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes
livenessProbe:
  enabled: false
  failureThreshold: 3
  initialDelaySeconds: 180
  periodSeconds: 10
  successThreshold: 1
  timeoutSeconds: 5

# -- Custom livenessProbe
livenessProbeCustom: {}
  # httpGet:
  #   path: /dashboard
  #   port: 4000
  # failureThreshold: 3
  # initialDelaySeconds: 200
  # periodSeconds: 30
  # successThreshold: 1
  # timeoutSeconds: 5

# -- Configure readinessProbe checker
# </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes
readinessProbe:
  enabled: false
  failureThreshold: 3
  initialDelaySeconds: 10
  periodSeconds: 10
  successThreshold: 1
  timeoutSeconds: 1

# -- Custom readinessProbe
readinessProbeCustom: {}
  # httpGet:
  #   path: /dashboard
  #   port: 4000
  # failureThreshold: 3
  # initialDelaySeconds: 200
  # periodSeconds: 30
  # successThreshold: 1
  # timeoutSeconds: 5

# -- Configure startupProbe checker
# </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes
startupProbe:
  enabled: false
  failureThreshold: 30
  initialDelaySeconds: 180
  periodSeconds: 10
  successThreshold: 1
  timeoutSeconds: 5

# -- Custom startupProbe
startupProbeCustom: {}
  # httpGet:
  #   path: /dashboard
  #   port: 4000
  # failureThreshold: 3
  # initialDelaySeconds: 200
  # periodSeconds: 30
  # successThreshold: 1
  # timeoutSeconds: 5

# -- Check if dependencies are ready
readyChecker:
  # -- Enable or disable ready-checker
  enabled: true
  # -- Repository of the image
  repository: busybox
  # -- Pull policy for the image
  pullPolicy: IfNotPresent
  # -- Overrides the image tag
  tag: latest
  # -- Number of retries before giving up
  retries: 30
  # -- Timeout for each check
  timeout: 5
  # -- List services
  services:
  - name: mongodb
    port: 27017
  - name: keycloak
    port: 8080
  - name: minio
    port: 9000
  - name: oauth2proxy
    port: 80

# -- Enable ServiceMonitor to get metrics
# </br> Ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#servicemonitor
serviceMonitor:
  # -- Enable or disable
  enabled: false
  interval: 30s
  scrapeTimeout: 10s
  metricRelabelings: []
  relabelings: []

# -- Configure annotations on Pods
podAnnotations: {}

# -- Configure labels on Pods
podLabels: {}

# -- Defines privilege and access control settings for a Pod
# </br> Ref: https://kubernetes.io/docs/concepts/security/pod-security-standards/
# </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
podSecurityContext: {}
  # fsGroup: 2000

# -- Defines privilege and access control settings for a Container
# </br> Ref: https://kubernetes.io/docs/concepts/security/pod-security-standards/
# </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# -- Resources limits and requested
# </br> Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
resources: {}
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# -- Pod Disruption Budget
# </br> Ref: https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/pod-disruption-budget-v1/
podDisruptionBudget:
  enabled: false
  maxUnavailable: 1
  minAvailable:

# -- Autoscaling with CPU or memory utilization percentage
# </br> Ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# -- Additional volumes on the output Deployment definition
# </br> Ref: https://kubernetes.io/docs/concepts/storage/volumes/
# </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/
# </br> Ref: https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/#create-a-pod-that-has-access-to-the-secret-data-through-a-volume
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# -- Additional volumeMounts on the output Deployment definition
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

# -- Persistent Volume configuration
# </br> Ref: https://kubernetes.io/docs/concepts/storage/persistent-volumes/
persistentVolume:
  # -- Enable or disable persistence
  enabled: false

  # -- Persistent Volume access modes
  # Must match those of existing PV or dynamic provisioner
  # </br> Ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
  accessModes:
    - ReadWriteOnce

  # -- Persistent Volume annotations
  annotations: {}

  # -- Persistent Volume labels
  labels: {}

  # -- Persistent Volume size
  size: 8Gi

  # -- Persistent Volume Storage Class
  # If defined, storageClassName: <storageClass>
  # If set to "-", storageClassName: "", which disables dynamic provisioning
  # If undefined (the default) or set to null, no storageClassName spec is
  #   set, choosing the default provisioner.  (gp2 on AWS, standard on
  #   GKE, AWS & OpenStack)
  storageClass: ""

  # -- Persistent Volume Binding Mode
  # If defined, volumeBindingMode: <volumeBindingMode>
  # If undefined (the default) or set to null, no volumeBindingMode spec is
  # set, choosing the default mode.
  volumeBindingMode: ""

  # -- Persistent Volume Claim Selector
  # Useful if Persistent Volumes have been provisioned in advance
  # </br> Ref: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#selector
  selector: {}
    # matchLabels:
    #   release: "stable"
    # matchExpressions:
    #   - { key: environment, operator: In, values: [ dev ] }

  # -- Persistent Volume Name
  # Useful if Persistent Volumes have been provisioned in advance and you want to use a specific one
  volumeName: ""

# -- Node labels for pod assignment
# </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
nodeSelector: {}

# -- Tolerations for pod assignment
# </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
tolerations: []

# -- Affinity for pod assignment
# </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
affinity: {}

# -- Control how Pods are spread across your cluster
# </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#example-multiple-topologyspreadconstraints
topologySpreadConstraints: []
# - maxSkew: 1
#   topologyKey: zone
#   whenUnsatisfiable: DoNotSchedule

# -- (DEPRECATION) Backup job configuration
# -- Use external service such as Velero
backup:
  # -- Whether to enable backup
  enabled: false
  # -- Backup cronjob schedule
  schedule: "0 1 * * 0" # every sunday at 1:00 AM
  # -- Name of the backup cronjob
  name: backup-gitea
  image:
    # -- Image repository
    repository: konstellation/kdl-backup
    # -- Image pull policy
    pullPolicy: IfNotPresent
    # -- Image tag
    tag: 0.23.0

  # -- Specifies how to treat concurrent executions of a Job. Ref: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#concurrency-policy
  concurrencyPolicy: Forbid

  # -- The number of failed finished jobs to retain. Ref: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#jobs-history-limits
  failedJobsHistoryLimit: 1

  # -- The number of successful finished jobs to retain. Ref: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#jobs-history-limits
  successfulJobsHistoryLimit: 0

  # -- Optional deadline in seconds for starting the job if it misses scheduled time for any reason. Missed jobs executions will be counted as failed ones. Ref: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#job-creation
  startingDeadlineSeconds: 60

  # -- Sets the backoffLimit param for the backup cronjob. Ref: https://kubernetes.io/docs/concepts/workloads/controllers/job/#pod-backoff-failure-policy
  backoffLimit: 3

  # -- Sets the activeDeadlineSeconds param for the backup cronjob. Ref: https://kubernetes.io/docs/concepts/workloads/controllers/job/#job-termination-and-cleanup
  activeDeadlineSeconds: 3600

  # -- Limits the lifetime of a Job that has finished execution (either Complete or Failed).
  ttlSecondsAfterFinished: ""

  # -- AWS S3 Bucket configuration
  s3:
    # -- AWS Access Key ID for acceding backup bucket
    awsAccessKeyID: aws-access-key-id
    # -- AWS Secret Access Key for acceding backup bucket
    awsSecretAccessKey: aws-secret-access-key
    # -- The S3 bucket that will store all backups
    bucketName: s3-bucket-name

  # -- Resources limits and requested
  # </br> Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  # -- Extra volume mounts for backup pods
  extraVolumeMounts: []
  # extraVolumeMounts:
  #   - name: shared-storage
  #     mountPath: /backup
  #     readOnly: true

  # -- Extra volumes for backup pods
  extraVolumes: []
  # extraVolumes:
  #   - name: shared-storage
  #     hostPath:
  #       path: /backup
  #       type: Directory

# -- Cleaner job configuration
cleaner:
  # -- Whether to enable cleaner cronjob
  enabled: false

  # -- Image registry
  # The image configuration for the base service
  image:
    # The repository of the image
    repository: konstellation/kdl-cleaner
    # The pull policy for the image
    pullPolicy: IfNotPresent
    # The image tag
    tag: 0.16.0

  # -- Specifies the secrets to use for pulling images from private registries
  # Leave empty if no secrets are required
  # E.g.
  # imagePullSecrets:
  #   - name: myRegistryKeySecretName
  imagePullSecrets: []

  # -- Specifies how to treat concurrent executions of a Job.
  # ref: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#concurrency-policy
  concurrencyPolicy: "Forbid"

  # -- Specifies the maximum number of failed finished jobs to retain.
  # ref: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#jobs-history-limits
  failedJobsHistoryLimit: 5

  # -- Specifies the maximum number of successful finished jobs to retain.
  # ref: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#jobs-history-limits
  successfulJobsHistoryLimit: 2

  # -- Optional deadline in seconds for starting the job if it misses its scheduled time for any reason.
  # ref: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#cron-job-limitations
  startingDeadlineSeconds: 60

  # -- Specifies the number of retries before marking a job as failed.
  # ref: https://kubernetes.io/docs/concepts/workloads/controllers/job/#pod-backoff-failure-policy
  backoffLimit: 3

  # -- Specifies the duration in seconds relative to the start time that the job may be active before the system tries to terminate it.
  # ref: https://kubernetes.io/docs/concepts/workloads/controllers/job/#job-termination-and-cleanup
  activeDeadlineSeconds: 86400

  # -- Schedule for the cleaner cronjob
  # example: every sunday at 1:00 AM
  schedule: "0 1 * * 0"

  # -- The name of the trash path
  trashPath: /shared-storage/.trash

  # -- The minimun age of files to be removed
  threshold: 5 # minimun age of files to be removed

  # -- Additional volumes on the output Deployment definition
  # </br> Ref: https://kubernetes.io/docs/concepts/storage/volumes/
  # </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/
  # </br> Ref: https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/#create-a-pod-that-has-access-to-the-secret-data-through-a-volume
  volumes: []
  # - name: foo
  #   secret:
  #     secretName: mysecret
  #     optional: false

  # -- Additional volumeMounts on the output Deployment definition
  volumeMounts: []
  # - name: foo
  #   mountPath: "/etc/foo"
  #   readOnly: true

  # -- Resources limits and requested
  # </br> Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  resources: {}
    # limits:
    #   cpu: "100m"
    #   memory: "128Mi"
    # requests:
    #   cpu: "50m"
    #   memory: "64Mi"

# -- Gitea deployment
# (DEPRECATION) Remove in future versions
gitea:
  # -- Whether to enable Gitea
  enabled: true

  admin:
    # -- Admin username
    username: "kdladmin"
    # -- Admin password
    password: "123456"
    # -- Admin user email
    email: test@test.com
  image:
    # The repository of the image
    repository: gitea/gitea
    # The image tag
    tag: 1.14.4
    # The pull policy for the image
    pullPolicy: IfNotPresent
  storage:
    # -- Storage size
    size: 10Gi
    # -- Storage class name
    storageClassName: standard
  ingress:
    # -- The ingress class name
    className: "nginx"

    tls:
      # -- The TLS secret name that will be used. It takes precedence over `.Values.global.ingress.tls.secretName`.
      secretName: null
    # -- Ingress annotations
    annotations:
      ## This Chart has been developed using Nginx Ingress Controller by default.
      ## Using the following default annotations ensures its correct operation.
      ## Ref: https://kubernetes.github.io/ingress-nginx/
      ##
      nginx.ingress.kubernetes.io/configuration-snippet: |
        more_set_headers "Content-Security-Policy: frame-ancestors 'self' *";
      ## In case of additional security to be required set the previous annotation as follows
      ##
      # nginx.ingress.kubernetes.io/configuration-snippet: |
      #   more_set_headers "Content-Security-Policy: frame-ancestors 'self' https://kdlapp.kdl.local";

  # -- Node labels for pod assignment
  # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
  nodeSelector: {}

  # -- Tolerations for pod assignment
  # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []

  # -- Affinity for pod assignment
  # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}

giteaOauth2Setup:
  image:
    # The repository of the image
    repository: konstellation/kdl-gitea-oauth2-setup
    # The image tag
    tag: 0.16.0
    # The pull policy for the image
    pullPolicy: IfNotPresent

# -- Keycloak subchart deployment
# </br> Ref: https://github.com/konstellation-io/helm-charts/blob/kdl-server-1.0.2/charts/kdl-server/values.yaml
keycloak:
  # -- Enable or disable Keycloak subchart
  enabled: true

  # Force keycloak name
  fullnameOverride: keycloak

  # Image registry
  # The image configuration for the base service
  image:
    repository: keycloak/keycloak
    tag: "26.0"

  # Kubernetes service to expose Pod
  # </br> Ref: https://kubernetes.io/docs/concepts/services-networking/service/
  service:
    healthPath: /realms/master
    targetPort: 8080

  # Ingress configuration to expose app
  # </br> Ref: https://kubernetes.io/docs/concepts/services-networking/ingress/
  ingress:
    enabled: true
    className: ""
    annotations: {}
      # nginx.org/proxy-buffer-size: "128k"
      # nginx.org/proxy-buffers: "8 256k"
    hosts:
    - host: keycloak.mydomain.com
      paths:
      - path: /
        pathType: ImplementationSpecific

  # Enable creation of ServiceAccount
  # </br> Ref: https://kubernetes.io/docs/concepts/security/service-accounts/
  serviceAccount:
    create: true

  # Configure liveness checker
  # </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes
  livenessProbe:
    enabled: true

  # Configure readinessProbe checker
  # </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes
  readinessProbe:
    enabled: true
    httpGet:
      path: /realms/master

  # Configure command
  # </br> Ref: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []
  # - "/opt/keycloak/bin/kc.sh"
  # - "start-dev"

  # Environment variables to configure application
  # </br> Ref: https://www.keycloak.org/server/configuration
  env: {}
    # KC_DB_PASSWORD: keycloak
    # KC_DB_URL: jdbc:postgresql://postgresql:5432/keycloak
    # KC_DB_USERNAME: keycloak
    # KC_DB: postgres
    # KC_HEALTH_ENABLED: true
    # KC_HOSTNAME: keycloak.mydomain.com
    # KC_METRICS_ENABLED: true
    # KC_PROXY: edge
    # KEYCLOAK_ADMIN_PASSWORD: keycloak
    # KEYCLOAK_ADMIN: keycloak

# -- knowledge-galaxy deployment
# </br> Ref: https://github.com/konstellation-io/knowledge-galaxy
knowledgeGalaxy:
  # -- Whether to enable Knowledge Galaxy
  enabled: false

  # -- Image registry
  # The image configuration for the base service
  image:
    # The repository of the image
    repository: konstellation/knowledge-galaxy
    # The pull policy for the image
    pullPolicy: IfNotPresent
    # The image tag
    tag: v1.2.1

  # -- Specifies the secrets to use for pulling images from private registries
  # Leave empty if no secrets are required
  # E.g.
  # imagePullSecrets:
  #   - name: myRegistryKeySecretName
  imagePullSecrets: []

  # -- Configuration
  # TODO: legacy backard compatibility, remove in future versions
  config:
    # -- Log level
    logLevel: "INFO"
    # -- Number of threads for the server
    workers: 1
    # -- Number of outputs that the recommender returns
    numberOfOutputs: 1000
    # -- Minimum number of words to use for project description
    descriptionMinWords: 50

  # -- Enable creation of ServiceAccount
  # </br> Ref: https://kubernetes.io/docs/concepts/security/service-accounts/
  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Automatically mount a ServiceAccount's API credentials?
    automount: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  # -- Environment variables to configure application
  # Ref: https://github.com/konstellation-io/knowledge-galaxy?tab=readme-ov-file#environment-variables
  env: {}
    # DESCRIPTION_MIN_WORDS: 50
    # HOST: "0.0.0.0"
    # LOG_LEVEL: "INFO"
    # N_HITS: 1000
    # SERVER_MONGODB_URI: mongodb://mongodb:27017
    # SERVER_PORT: 8080
    # STANDALONE_MODE: "false"
    # WORKERS: "1"

  # -- Variables from secrets
  envFromSecrets: {}
    # MY_VARIABLE:
    #  name: <name-secret>
    #  key: secret_key

  # -- Variables from configMap
  envFromConfigMap: {}
    # MY_VARIABLE:
    #  name: <name-configmap>
    #  key: key

  # -- Variables from files managed by you
  # </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#configure-all-key-value-pairs-in-a-configmap-as-container-environment-variables
  envFromFiles: {}
    # - secretRef:
    #     name: <name-secret>
    # - configMapRef:
    #     name: <name-configmap>

  # -- Secrets values to create credentials and reference by envFromSecrets
  # Generate Secret with following name: <release-name>-<name>
  # </br> Ref: https://kubernetes.io/docs/concepts/configuration/secret/
  secrets: {}
    # - name: secret-name
    #   data:
    #     my.key: |-
    #       my-content
    #     my_var: my-value

  # -- Configure additional containers
  # </br> Ref: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  initContainers: []
    # - name: my-container
    #   image: busybox
    #   command: ['sh', '-c', 'echo "Hello, World!"']

  # -- Configure args
  # </br> Ref: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  args: []
    # - -c
    # - echo "Hello, World!"

  # -- Configure command
  # </br> Ref: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []
    # - echo
    # - "Hello, World!"

  # -- Kubernetes service to expose Pod
  # </br> Ref: https://kubernetes.io/docs/concepts/services-networking/service/
  service:
    # -- Kubernetes Service type. Allowed values: NodePort, LoadBalancer or ClusterIP
    type: ClusterIP
    # -- Kubernetes Service port
    port: 80
    # -- Kubernetes Service health check path
    # healthPath: ""
    # -- NodePort port (only when type is NodePort)
    # nodePort: 32000
    # -- Pod expose port
    targetPort: 8080
    # -- Pod extra ports
    # extraPorts:
    # - name: metrics
    #   port: 9080
    #   targetPort: 9080

  # -- NetworkPolicy configuration
  # </br> Ref: https://kubernetes.io/docs/concepts/services-networking/network-policies/
  networkPolicy:
    # -- Enable or disable NetworkPolicy
    enabled: false
    # -- Policy types
    policyTypes: []
      # - Ingress
      # - Egress
    ingress: []
      # - from:
      #   - ipBlock:
      #       cidr: 172.17.0.0/16
      #       except:
      #       - 172.17.1.0/24
      #   - namespaceSelector:
      #       matchLabels:
      #         project: myproject
      #   - podSelector:
      #       matchLabels:
      #         role: frontend
      #   ports:
      #   - protocol: TCP
      #     port: 6379
    egress: []
      # - to:
      #   - ipBlock:
      #       cidr: 10.0.0.0/24
      #   ports:
      #   - protocol: TCP
      #     port: 5978

  # -- Configure lifecycle hooks
  # </br> Ref: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/
  # </br> Ref: https://learnk8s.io/graceful-shutdown
  lifecycle: {}
    # preStop:
    #   exec:
    #     command: ["sh", "-c", "sleep 10"]

  # -- Configure Pod termination grace period
  # </br> Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination
  terminationGracePeriodSeconds: 30

  # -- Configure liveness checker
  # </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes
  livenessProbe:
    enabled: false
    failureThreshold: 3
    initialDelaySeconds: 180
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5

  # -- Custom livenessProbe
  livenessProbeCustom: {}
    # httpGet:
    #   path: /dashboard
    #   port: 4000
    # failureThreshold: 3
    # initialDelaySeconds: 200
    # periodSeconds: 30
    # successThreshold: 1
    # timeoutSeconds: 5

  # -- Configure readinessProbe checker
  # </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes
  readinessProbe:
    enabled: false
    failureThreshold: 3
    initialDelaySeconds: 10
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1

  # -- Custom readinessProbe
  readinessProbeCustom: {}
    # httpGet:
    #   path: /dashboard
    #   port: 4000
    # failureThreshold: 3
    # initialDelaySeconds: 200
    # periodSeconds: 30
    # successThreshold: 1
    # timeoutSeconds: 5

  # -- Configure startupProbe checker
  # </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes
  startupProbe:
    enabled: false
    failureThreshold: 30
    initialDelaySeconds: 180
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5

  # -- Custom startupProbe
  startupProbeCustom: {}
    # httpGet:
    #   path: /dashboard
    #   port: 4000
    # failureThreshold: 3
    # initialDelaySeconds: 200
    # periodSeconds: 30
    # successThreshold: 1
    # timeoutSeconds: 5

  # -- Configure annotations on Pods
  podAnnotations: {}

  # -- Configure labels on Pods
  podLabels: {}

  # -- Defines privilege and access control settings for a Pod
  # </br> Ref: https://kubernetes.io/docs/concepts/security/pod-security-standards/
  # </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  podSecurityContext: {}
    # fsGroup: 2000

  # -- Defines privilege and access control settings for a Container
  # </br> Ref: https://kubernetes.io/docs/concepts/security/pod-security-standards/
  # </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  # -- Resources limits and requested
  # </br> Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  # -- Pod Disruption Budget
  # </br> Ref: https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/pod-disruption-budget-v1/
  podDisruptionBudget:
    enabled: false
    maxUnavailable: 1
    minAvailable:

  # -- Autoscaling with CPU or memory utilization percentage
  # </br> Ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80

  # -- Additional volumes on the output Deployment definition
  # </br> Ref: https://kubernetes.io/docs/concepts/storage/volumes/
  # </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/
  # </br> Ref: https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/#create-a-pod-that-has-access-to-the-secret-data-through-a-volume
  volumes: []
  # - name: foo
  #   secret:
  #     secretName: mysecret
  #     optional: false

  # -- Additional volumeMounts on the output Deployment definition
  volumeMounts: []
  # - name: foo
  #   mountPath: "/etc/foo"
  #   readOnly: true

  # -- Node labels for pod assignment
  # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
  nodeSelector: {}

  # -- Tolerations for pod assignment
  # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []

  # -- Affinity for pod assignment
  # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}

  # -- Control how Pods are spread across your cluster
  # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#example-multiple-topologyspreadconstraints
  topologySpreadConstraints: []
  # - maxSkew: 1
  #   topologyKey: zone
  #   whenUnsatisfiable: DoNotSchedule

# -- (DEPRECATION) MinIO chart's values. Check MinIO chart's [documentation](https://github.com/minio/minio/tree/master/helm/minio) for more info about values
# @default -- Check [values.yaml](./values.yaml)
# minio:
#   enabled: false
#   legacy: true
#   resources:
#     requests:
#       memory: 1Gi
#   mode: standalone
#   rootUser: "minio"
#   rootPassword: "minio123"
#   serviceAccount:
#     create: false
#   persistence:
#     storageClass: standard
#     existingClaim: ""
#     accessMode: ReadWriteMany

#   # -- Define which Nodes the Pods are scheduled on. Ref: https://kubernetes.io/docs/user-guide/node-selection/
#   nodeSelector: {}

#   # -- Assign custom affinity rules. Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
#   affinity: {}

#   # -- If specified, the pod's tolerations. Ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
#   tolerations: []

#   ## This Chart uses custom ingresses for MinIO and MinIO Console and not
#   ## the ones implemented by the official MinIO Chart which are disabled by default
#   ##
#   ingress:
#     # -- The ingress class name
#     className: "nginx"
#     tls:
#       # -- The TLS secret name that will be used. It takes precedence over `.Values.global.ingress.tls.secretName`.
#       secretName: null
#     # -- Ingress annotations
#     annotations:
#       nginx.ingress.kubernetes.io/proxy-body-size: "1000000m"

#   consoleIngress:
#     # The ingress class name
#     className: "nginx"
#     tls:
#       # -- The TLS secret name that will be used. It takes precedence over `.Values.global.ingress.tls.secretName`.
#       secretName: null
#     # -- Ingress annotations
#     annotations:
#       nginx.ingress.kubernetes.io/proxy-body-size: "1000000m"

# -- MinIO subchart deployment
# </br> Ref: https://github.com/bitnami/charts/blob/main/bitnami/minio/values.yaml
# TODO: pending to remove legacy minio
minio:
  # -- Enable or disable MinIO subchart
  enabled: true

  # mode MinIO server mode (`standalone` or `distributed`)
  # </br> Ref: https://docs.minio.io/docs/distributed-minio-quickstart-guide
  mode: standalone

  # MinIO authentication parameters
  auth:
    # MinIO root username
    rootUser: ChangeMe
    # Password for MinIO root user
    rootPassword: ChangeMe

  # Enable persistence using Persistent Volume Claims
  # </br> Ref: https://kubernetes.io/docs/user-guide/persistent-volumes/
  persistence:
    # Enable MinIO data persistence using PVC. If false, use emptyDir
    enabled: false

# -- MongoDB subchart deployment
# </br> Ref: https://github.com/bitnami/charts/blob/main/bitnami/mongodb/values.yaml
mongodb:
  # -- Enable or disable MongoDB subchart
  enabled: false

  # mode MongoDB server mode (`standalone` or `replicaset`)
  architecture: standalone

  # MongoDB authentication parameters
  auth:
    # MongoDB root username
    rootUser: ChangeMe
    # Password for MongoDB root user
    rootPassword: ChangeMe

  # Enable persistence using Persistent Volume Claims
  # </br> Ref: https://kubernetes.io/docs/user-guide/persistent-volumes/
  persistence:
    # Enable MongoDB data persistence using PVC. If false, use emptyDir
    enabled: false

# (DEPRECATION) legacy, remove in future versions
# OAuth2-Proxy legacy to configure user authentication
oauth2Proxy:
  image:
    # The repository of the image
    repository: quay.io/oauth2-proxy/oauth2-proxy
    # The image tag
    tag: v7.0.1-amd64
    # The pull policy for the image
    pullPolicy: IfNotPresent
  config:
    # -- The seed string for secure cookies. Ref: https://oauth2-proxy.github.io/oauth2-proxy/docs/configuration/overview
    cookieSecret: "mycookiesecret16"
  # -- The OAuth2-Proxy custom configuration file
  customConfig:
  #  |-
  #  provider = "github"
  #  client

# -- OAuth2-Proxy subchart deployment
# </br> Ref: https://github.com/oauth2-proxy/manifests/blob/main/helm/oauth2-proxy/values.yaml
oauth2proxy:
  # -- Enable or disable OAuth2-Proxy subchart
  enabled: false

  # whether to use http or https
  httpScheme: http
  # OAuth client ID
  clientID: "XXXXXXX"
  # OAuth client secret
  clientSecret: "XXXXXXXX"
  # Create a new secret with the following command
  # openssl rand -base64 32 | head -c 32 | base64
  # Use an existing secret for OAuth2 credentials (see secret.yaml for required fields)
  # Example:
  # existingSecret: secret
  cookieSecret: "XXXXXXXX"
  # The name of the cookie that oauth2-proxy will create
  # If left empty, it will default to the release name
  cookieName: ""
  # Ref: https://oauth2-proxy.github.io/oauth2-proxy/configuration/overview#config-options
  # Ref: https://github.com/oauth2-proxy/oauth2-proxy/blob/master/contrib/oauth2-proxy.cfg.example
  # Ref: https://oauth2-proxy.github.io/oauth2-proxy/configuration/providers/keycloak_oidc
  # configFile: |-
  #   provider = "keycloak-oidc"
  #   client_id = "oauth2-proxy"
  #   client_secret = "XXXXXXXX"
  #   redirect_url = "https://domain.com/oauth2/callback"
  #   oidc_issuer_url = "https://keycloak.svc/realms/<realm>"
  #   email_domains = ["domain.com"]
  #   code_challenge_method = "S256"
  #   skip_provider_button = true
  #   pass_user_headers = true
  #   upstreams = [
  #     "http://127.0.0.1:8080/",
  #     "http://127.0.0.1:9000/mlflow/",
  #     "http://127.0.0.1:9000/filebrowser/",
  #     "http://127.0.0.1:9000/kg/"
  #   ]
  #   skip_auth_routes = ["/config.json"]
  #   cookie_secret = "XXXXXXXX"
  #   cookie_secure = true
  #   cookie_httponly = true

  extraContainers: []
    #  - name: project-proxy
    #    image: nginx:alpine
    #    ports:
    #      - containerPort: 9000
    #    volumeMounts:
    #      - name: project-proxy-nginx-config
    #        mountPath: /etc/nginx/nginx.conf
    #        subPath: nginx.conf

  extraVolumes: []
    # - name: project-proxy-nginx-config
    #   configMap:
    #     name: project-proxy-nginx-config

  extraVolumeMounts: []
    # - name: project-proxy-nginx-config
    #   mountPath: /etc/nginx/nginx.conf
    #   subPath: nginx.conf

  extraObjects: []
    # Ref: https://oauth2-proxy.github.io/oauth2-proxy/configuration/integration
    # - apiVersion: v1
    #   kind: ConfigMap
    #   metadata:
    #     name: project-proxy-nginx-config
    #   data:
    #     nginx.conf: |
    #       user  nginx;
    #       worker_processes  1;
    #       error_log  /var/log/nginx/error.log warn;
    #       pid        /var/run/nginx.pid;
    #       events {
    #           worker_connections  1024;
    #       }
    #       http {
    #         include       /etc/nginx/mime.types;
    #         default_type  application/octet-stream;
    #         log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                             '$status $body_bytes_sent "$http_referer" '
    #                             '"$http_user_agent" "$http_x_forwarded_for"';
    #         access_log  /var/log/nginx/access.log  main;
    #         sendfile        on;
    #         keepalive_timeout  65;
    #
    #         server {
    #           listen 9000;
    #           resolver kube-dns.kube-system.svc.cluster.local valid=5s;
    #           client_max_body_size 1000000M;
    #
    #           location = /auth {
    #               internal;
    #               proxy_pass              http://127.0.0.1:8080/api/auth/project;
    #               proxy_pass_request_body off;
    #               proxy_set_header        Content-Length "";
    #               proxy_set_header        X-Original-URI $request_uri;
    #           }
    #
    #           location ~ ^/mlflow/([^/]+)/(.*)$ {
    #               auth_request /auth;
    #               auth_request_set $auth_status $upstream_status;
    #               proxy_pass http://$1-mlflow.kdl.svc.cluster.local:5000/$2$is_args$args;
    #           }
    #
    #           location ~ ^/filebrowser/([^/]+)/(.*)$ {
    #               auth_request /auth;
    #               auth_request_set $auth_status $upstream_status;
    #               set $query $2;
    #               proxy_pass http://$1-filebrowser.kdl.svc.cluster.local:9696/$query$is_args$args;
    #           }
    #
    #           location ~ ^/kg/(api|static)/(.*)$ {
    #               proxy_pass http://knowledge-galaxy.kdl.svc.cluster.local:8080/kg/$1/$2$is_args$args;
    #           }
    #
    #           location ~ ^/kg/(favicon.ico|config.json)$ {
    #               proxy_pass http://knowledge-galaxy.kdl.svc.cluster.local:8080/kg/$1;
    #           }
    #
    #           location ~ ^/kg/(.*)$ {
    #               auth_request /auth;
    #               auth_request_set $auth_status $upstream_status;
    #               proxy_pass http://knowledge-galaxy.kdl.svc.cluster.local:8080/kg/$1$is_args$args;
    #           }
    #         }
    #       }

# (LEGACY) Until gitea is used
postgres:
  image:
    # -- The image repository
    repository: postgres
    # -- The image tag
    tag: 12.1
    # -- The image pull policy
    pullPolicy: IfNotPresent
  # -- The name of the Postgres database for Gitea
  dbName: gitea
  # -- The password for the Gitea's database
  dbPassword: test
  storage:
    # -- The storage size for the persistent volume claim
    size: 10Gi
    # -- Storage class to use for persistence
    storageClassName: ""

  # -- Define which Nodes the Pods are scheduled on. Ref: https://kubernetes.io/docs/user-guide/node-selection/
  nodeSelector: {}

  # -- Assign custom affinity rules. Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  affinity: {}

  # -- If specified, the pod's tolerations. Ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  tolerations: []

# -- PostgreSQL subchart deployment
# </br> Ref: https://github.com/bitnami/charts/blob/main/bitnami/postgresql/values.yaml
postgresql:
    # -- Enable or disable PostgreSQL subchart
  enabled: true

  # Number of PostgreSQL replicas to deploy
  replicaCount: 1

  # PostgreSQL Authentication parameters
  auth:
    # PostgreSQL application username
    # </br> Ref: https://github.com/bitnami/containers/tree/main/bitnami/postgresql#environment-variables
    username: user
    # PostgreSQL application password
    # </br> Ref: https://github.com/bitnami/containers/tree/main/bitnami/postgresql#environment-variables
    password: ChangeMe
    # PostgreSQL application database
    # </br> Ref: https://github.com/bitnami/containers/tree/main/bitnami/postgresql#environment-variables
    database: "kdl"

  # Enable persistence using Persistent Volume Claims
  primary:
    # Persistence parameters
    persistence:
      # Enable PostgreSQL data persistence using PVC
      enabled: false

# -- project-operator operator
projectOperator:
  # -- Enable or disable project-operator
  enabled: true

  # -- Image registry
  # The image configuration for the base service
  image:
    # The repository of the image
    repository: konstellation/kdl-project-operator
    # The pull policy for the image
    pullPolicy: IfNotPresent
    # The image tag
    tag: 0.19.0

  # Additional containers to be added to the pod
  extraContainers:
    - name: kube-rbac-proxy
      image: gcr.io/kubebuilder/kube-rbac-proxy:v0.8.0
      imagePullPolicy: IfNotPresent
      args:
      - --secure-listen-address=0.0.0.0:8443
      - --upstream=http://127.0.0.1:8080/
      - --logtostderr=true
      - --v=10
      ports:
      - containerPort: 8443
        name: https

  # -- Specifies the secrets to use for pulling images from private registries
  # Leave empty if no secrets are required
  # E.g.
  # imagePullSecrets:
  #   - name: myRegistryKeySecretName
  imagePullSecrets: []

  # -- Enable creation of ServiceAccount
  # </br> Ref: https://kubernetes.io/docs/concepts/security/service-accounts/
  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Automatically mount a ServiceAccount's API credentials?
    automount: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  # -- Configure additional containers
  # </br> Ref: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  initContainers: []
    # - name: my-container
    #   image: busybox
    #   command: ['sh', '-c', 'echo "Hello, World!"']

  # -- Configure args
  # </br> Ref: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  args:
    - --health-probe-bind-address=:8081
    - --metrics-bind-address=127.0.0.1:8080
    - --leader-elect
    - --leader-election-id=project-operator

  # -- Configure command
  # </br> Ref: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []
    # - echo
    # - "Hello, World!"

  # -- Kubernetes service to expose Pod
  # </br> Ref: https://kubernetes.io/docs/concepts/services-networking/service/
  service:
    # -- Kubernetes Service type. Allowed values: NodePort, LoadBalancer or ClusterIP
    type: ClusterIP
    # -- Kubernetes Service port
    port: 80
    # -- Kubernetes Service health check path
    # healthPath: ""
    # -- NodePort port (only when type is NodePort)
    # nodePort: 32000
    # -- Pod expose port
    targetPort: 8443
    # -- Pod extra ports
    # extraPorts:
    # - name: metrics
    #   port: 9080
    #   targetPort: 9080

  # -- Enable ServiceMonitor to get metrics
  # </br> Ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#servicemonitor
  serviceMonitor:
    # -- Enable or disable
    enabled: false
    interval: 30s
    scrapeTimeout: 10s
    metricRelabelings: []
    relabelings: []

  # -- Configure lifecycle hooks
  # </br> Ref: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/
  # </br> Ref: https://learnk8s.io/graceful-shutdown
  lifecycle: {}
    # preStop:
    #   exec:
    #     command: ["sh", "-c", "sleep 10"]
    # postStart:
    #   exec:
    #     command:
    #       - "/bin/sh"
    #       - "-c"
    #       - "ssh-keyscan -H gitea >> /app/.ssh/known_hosts"

  # -- Configure Pod termination grace period
  # </br> Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination
  terminationGracePeriodSeconds: 30

  # -- Configure annotations on Pods
  podAnnotations: {}

  # -- Configure labels on Pods
  podLabels: {}

  # -- Defines privilege and access control settings for a Pod
  # </br> Ref: https://kubernetes.io/docs/concepts/security/pod-security-standards/
  # </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  podSecurityContext: {}
    # fsGroup: 2000

  # -- Defines privilege and access control settings for a Container
  # </br> Ref: https://kubernetes.io/docs/concepts/security/pod-security-standards/
  # </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  securityContext:
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    runAsNonRoot: true
    # runAsUser: 1000

  # -- Resources limits and requested
  # </br> Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  # -- Pod Disruption Budget
  # </br> Ref: https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/pod-disruption-budget-v1/
  podDisruptionBudget:
    enabled: false
    maxUnavailable: 1
    minAvailable:

  # -- Autoscaling with CPU or memory utilization percentage
  # </br> Ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80

  # -- Node labels for pod assignment
  # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
  nodeSelector: {}

  # -- Tolerations for pod assignment
  # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []

  # -- Affinity for pod assignment
  # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}

  # -- Control how Pods are spread across your cluster
  # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#example-multiple-topologyspreadconstraints
  topologySpreadConstraints: []
  # - maxSkew: 1
  #   topologyKey: zone
  #   whenUnsatisfiable: DoNotSchedule

  ### Following values are used to configure the Project Operator
  ### This config pass on ConfigMap to KDL API create Project CRD with the
  ### desired configuration.
  # ref: https://github.com/konstellation-io/kdl-server/blob/main/project-operator/helm-charts/kdlproject/values.yaml

  # -- mlflow configuration
  mlflow:
    # -- Image registry
    # The image configuration for the base service
    image:
      # The repository of the image
      repository: konstellation/kdl-mlflow
      # The pull policy for the image
      pullPolicy: IfNotPresent
      # The image tag
      tag: v0.13.5

    volume:
      # -- Storage class to use for persistence
      storageClassName: standard
      # -- The storage size for the persistent volume claim
      size: 1Gi

    # -- Ingress configuration to expose app
    # </br> Ref: https://kubernetes.io/docs/concepts/services-networking/ingress/
    ingress:
      className: "nginx"
      annotations: {}
        # kubernetes.io/ingress.class: nginx
        # kubernetes.io/tls-acme: "true"
      tls:
        # -- The TLS secret name that will be used. It takes precedence over `.Values.global.ingress.tls.secretName`.
        secretName: null

    # -- Node labels for pod assignment
    # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
    nodeSelector: {}

    # -- Tolerations for pod assignment
    # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
    tolerations: []

    # -- Affinity for pod assignment
    # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
    affinity: {}

  # -- filebrowser configuration
  filebrowser:
    # -- Image registry
    # The image configuration for the base service
    image:
      # The repository of the image
      repository: filebrowser/filebrowser
      # The pull policy for the image
      pullPolicy: IfNotPresent
      # The image tag
      tag: v2

    # -- Node labels for pod assignment
    # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
    nodeSelector: {}

    # -- Tolerations for pod assignment
    # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
    tolerations: []

    # -- Affinity for pod assignment
    # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
    affinity: {}

# -- Persistent Volume configuration
# Mount volume to share data between components
# </br> Ref: https://kubernetes.io/docs/concepts/storage/persistent-volumes/
sharedVolume:
  # -- Enable or disable persistence
  enabled: false

  # -- Name of the shared volume
  # name: received-data

  # -- Persistent Volume access modes
  # Must match those of existing PV or dynamic provisioner
  # </br> Ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
  accessModes:
    - ReadWriteMany

  # -- Persistent Volume annotations
  annotations: {}

  # -- Persistent Volume labels
  labels: {}

  # -- Persistent Volume size
  size: 10Gi

  # -- Persistent Volume Storage Class
  # If defined, storageClassName: <storageClass>
  # If set to "-", storageClassName: "", which disables dynamic provisioning
  # If undefined (the default) or set to null, no storageClassName spec is
  #   set, choosing the default provisioner.  (gp2 on AWS, standard on
  #   GKE, AWS & OpenStack)
  storageClass: ""

  # -- Persistent Volume Binding Mode
  # If defined, volumeBindingMode: <volumeBindingMode>
  # If undefined (the default) or set to null, no volumeBindingMode spec is
  # set, choosing the default mode.
  volumeBindingMode: ""

  # -- Persistent Volume Claim Selector
  # Useful if Persistent Volumes have been provisioned in advance
  # </br> Ref: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#selector
  selector: {}
    # matchLabels:
    #   release: "stable"
    # matchExpressions:
    #   - { key: environment, operator: In, values: [ dev ] }

  # -- Persistent Volume Name
  # Useful if Persistent Volumes have been provisioned in advance and you want to use a specific one
  volumeName: ""

# -- User Tools Operator deployment
# ref: https://github.com/konstellation-io/kdl-server/tree/main/user-tools-operator
userToolsOperator:
  # -- Enable or disable User Tools Operator deployment
  enabled: true

  # -- Image registry
  # The image configuration for the base service
  image:
    # The repository of the image
    repository: konstellation/kdl-user-tools-operator
    # The pull policy for the image
    pullPolicy: IfNotPresent
    # The image tag
    tag: 0.29.0

  # -- Specifies the secrets to use for pulling images from private registries
  # Leave empty if no secrets are required
  # E.g.
  # imagePullSecrets:
  #   - name: myRegistryKeySecretName
  imagePullSecrets: []

  # -- Enable creation of ServiceAccount
  # </br> Ref: https://kubernetes.io/docs/concepts/security/service-accounts/
  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Automatically mount a ServiceAccount's API credentials?
    automount: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  # -- Configure additional containers
  # </br> Ref: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  initContainers: []
    # - name: my-container
    #   image: busybox
    #   command: ['sh', '-c', 'echo "Hello, World!"']

  # -- Configure args
  # </br> Ref: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  args:
    - --health-probe-bind-address=:8081
    - --metrics-bind-address=127.0.0.1:8080
    # - --leader-elect
    # - --leader-election-id=user-tools-operator

  # -- Configure command
  # </br> Ref: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []
    # - echo
    # - "Hello, World!"

  # -- Configure lifecycle hooks
  # </br> Ref: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/
  # </br> Ref: https://learnk8s.io/graceful-shutdown
  lifecycle: {}
    # preStop:
    #   exec:
    #     command: ["sh", "-c", "sleep 10"]
    # postStart:
    #   exec:
    #     command:
    #       - "/bin/sh"
    #       - "-c"
    #       - "ssh-keyscan -H gitea >> /app/.ssh/known_hosts"

  # -- Configure Pod termination grace period
  # </br> Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination
  terminationGracePeriodSeconds: 30

  # -- Configure annotations on Pods
  podAnnotations: {}

  # -- Configure labels on Pods
  podLabels: {}

  # -- Defines privilege and access control settings for a Pod
  # </br> Ref: https://kubernetes.io/docs/concepts/security/pod-security-standards/
  # </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  podSecurityContext: {}
    # fsGroup: 2000

  # -- Defines privilege and access control settings for a Container
  # </br> Ref: https://kubernetes.io/docs/concepts/security/pod-security-standards/
  # </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  # -- Resources limits and requested
  # </br> Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  # -- Pod Disruption Budget
  # </br> Ref: https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/pod-disruption-budget-v1/
  podDisruptionBudget:
    enabled: false
    maxUnavailable: 1
    minAvailable:

  # -- Autoscaling with CPU or memory utilization percentage
  # </br> Ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80

  # -- Node labels for pod assignment
  # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
  nodeSelector: {}

  # -- Tolerations for pod assignment
  # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []

  # -- Affinity for pod assignment
  # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}

  # -- Control how Pods are spread across your cluster
  # </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#example-multiple-topologyspreadconstraints
  topologySpreadConstraints: []
  # - maxSkew: 1
  #   topologyKey: zone
  #   whenUnsatisfiable: DoNotSchedule

  ### Following values are used to configure the User Tools Operator
  ### This config pass on ConfigMap to KDL API create UserTools CRD with the
  ### desired configuration.
  # ref: https://github.com/konstellation-io/kdl-server/blob/main/user-tools-operator/helm-charts/usertools/values.yaml

  # -- Storage configuration
  storage:
    # -- The storage size for the persistent volume claim
    size: 10Gi
    # -- Storage class to use for persistence
    storageClassName: standard

  # -- repocloner configuration
  # The following components are managed by the manager container when `usertool` custom resources are detected
  repoCloner:
    # -- Image registry
    # The image configuration for the base service
    image:
      # The repository of the image
      repository: konstellation/kdl-repo-cloner
      # The pull policy for the image
      pullPolicy: IfNotPresent
      # The image tag
      tag: 0.18.0

  # -- vscode configuration
  vscode:
    # -- Image registry
    # The image configuration for the base service
    image:
      # The repository of the image
      repository: konstellation/kdl-vscode
      # The pull policy for the image
      pullPolicy: IfNotPresent
      # The image tag
      tag: v0.15.0

  # -- vscodeRuntime configuration
  vscodeRuntime:
    # -- Image registry
    # The image configuration for the base service
    image:
      # The repository of the image
      repository: konstellation/kdl-py
      # The pull policy for the image
      pullPolicy: IfNotPresent
      # The image tag
      tag: "3.9"

  # Default ingress config for all deployed User Tools.
  #
  # This Chart has been developed using Nginx Ingress Controller by default.
  # Using the following default annotations ensures its correct operation.
  # Ref: https://kubernetes.github.io/ingress-nginx/
  #
  ingress:
    enabled: false
    className: "nginx"
    annotations:
      nginx.ingress.kubernetes.io/proxy-body-size: "1000000m"
      nginx.ingress.kubernetes.io/configuration-snippet: |
        more_set_headers "Content-Security-Policy: frame-ancestors 'self' *";
      # In case of additional security to be required set the previous annotation as follows
      #
      # nginx.ingress.kubernetes.io/configuration-snippet: |
      #   more_set_headers "Content-Security-Policy: frame-ancestors 'self' https://kdlapp.kdl.local";
    tls:
      # -- The TLS secret name that will be used. It takes precedence over `.Values.global.ingress.tls.secretName`.
      secretName: null

  # If enabled, users will be able to download a kubeconfig file, so they can attach an external terminal/IDE to
  # the vscodeRuntime running inside KST.
  # Ref: https://code.visualstudio.com/docs/remote/remote-overview
  kubeconfig:
    # -- Whether to enable kubeconfig for using with VSCode remote development.
    enabled: false
    # -- The Kube API Server URL for using with VSCode remote development
    externalServerUrl: ""
    ## Example:
    ##
    # enabled: true
    # externalServerUrl: https://192.168.0.21:16443

  # -- oauth2-proxy configuration
  oauth2Proxy:
    image:
      # The repository of the image
      repository: quay.io/oauth2-proxy/oauth2-proxy
      # The pull policy for the image
      pullPolicy: IfNotPresent
      # The image tag
      tag: v7.0.1-amd64
